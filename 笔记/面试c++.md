# 面试

## c++知识点

### 1、指针和引用

```shell
- 指针是一个变量，存储的是一个'地址'，引用跟原来的变量实质上是同一个东西，是原变量的'别名'
- 指针可以有'多级'，引用只有'一级'
- 指针可以'为空'，引用不能为NULL且在'定义时必须初始化'
- 指针在初始化后可以'改变指向'，而引用在初始化之后不可再改变
- sizeof指针得到的是本'指针的大小'，sizeof引用得到的是引用所'指向变量的大小'
- 当把指针作为参数进行传递时，也是将实参的一个'拷贝传递给形参'，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间；很对编译器对引用的实现就是const指针，因此会其占用的空间是一样的
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 在编译器看来, int a = 10; int &b = a; 等价于 int * const b = &a; 而 b = 20; 等价于 *b = 20; 
```

## 2、内存相关

### c++的内存分区

```shell
- 栈：是由编译器在需要时'自动分配'，不需要时'自动清除'的变量存储区。通常存放'局部变量'、'函数参数'等。
- 堆：是由'new'分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。
- 自由存储区：是由'malloc'等分配的内存块，和堆十分相似，用'free'来释放。
- 全局/静态存储区：'全局变量'和'静态变量'被分配到同一块内存中（在C语言中，全局变量又分为初始化的和未初始化的，C++中没有这一区分）。
- 常量存储区：这是一块特殊存储区，里边存放'常量'，不允许修改。
```

### 堆和栈的区别

|              | 堆                                                           | 栈                                                           |
| ------------ | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 管理方式     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |
| 内存管理机制 | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
| 空间大小     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit  系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在  编译时确定，VC中可设置） |
| 碎片问题     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低       | 对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片   |
| 分配方式     | 堆都是动态分配（没有静态分配的堆）                           | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数  分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现 |
| 分配效率     | 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多      | 栈是极其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令 |

### new、operator new()、::new、placement new

```shell
#new关键字
new内部有三个步骤：
1.调用operator new申请内存
2.调用构造函数生成对象
3.返回对应类型的指针
因此在C++中使用new关键字相当于先申请内存后执行构造函数；使用delete相当于先执行析构函数后释放内存。
#operator new()
默认是全局的::operator new()，可以在类中重载，此时new一个类会调用重载的operator new
重载时第一个参数为分配空间的大小，可以传入其他参数
重载时返回值为void*，即这片内存空间
operator new和operator delete与malloc和free对应，只负责分配以及释放空间；一个在'堆'一个在'自由存储区'
#placement new
是对operator new的一个重载
```

